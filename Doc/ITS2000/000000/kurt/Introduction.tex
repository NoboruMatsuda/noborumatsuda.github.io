\section{Introduction}

When one wishes to teach students in a complex problem-solving domain,
it is desired to provide students with better models of how to solve
problems.  Those models should be visualized and manipulatable; that is,
we need a better reification of the domain.  Especially, a reification
of problem-solving strategies is one of the key issues that affect the
quality of instructions in such complex domains.  By ``problem-solving
strategies'' we mean domain independent knowledge to conduct searches
through a problem space.  It might include carrying out a backward or a
forward inference step, backing-up an alternative inference at a
dead-end, switching over backward and forward inference, and so forth.

Despite the complexity of the domain, most of the time, when we design
an intelligent tutoring system with an articulate expert system, we
believe that since the built-in expert system holds a ``cognitive
model,'' observing and/or working along the embedded cognitive model is
enough for students to understand the domain.  This design policy
appears as a form of hints generated by the ITS or a form of user
interface.  That is, it might be assumed, for example, that showing a
problem-solving tree is good enough to explain how to solve a problem.
It might also be assumed that providing a list of possible operators are
good enough for students to learn the domain by solving problems.
However, careful observation of the inside of the problem-solving
strategies implies the difficulties for students to learn those
strategies as well as the design issues to build ITSs. 

In this paper, we focus on the procedures to carry out backward and
forward inferences.  From an AI standpoint, they just tell how to apply
operators --- for a forward inference, seek an operator that has all the
preconditions satisfied and execute the action part, and for a backward
inference, seek an operator that has an effect matched against a current
goal and establish subgoals with the unsatisfied preconditions.  From a
cognitive and instructional standpoint, however, they are rather much
complicated as discussed below.

\newcommand{\g}{\textit{\textbf{g}}}
\newcommand{\G}{\textbf{G}}
\newcommand{\op}{\textit{\textbf{op}}}
\newcommand{\OP}{\textbf{OP}}

First, carrying out a backward inference might require nondeterministic
decision making and complex cognitive procedures.  Given a set of goals
to be achieved in the goal stack (\G) and a set of operators (\OP), a
backward inference consists of following basic steps.

\begin{enumerate}
 \item Select a single goal \g\ $\in$ \G, and remove \g\ from \G.
 \item Match \g\ against the known facts in the current state.  If such
       fact is found, then the goal is achieved. 
 \item If the previous step fails, then \textit{choose} an operator \op\
       $\in$ \OP\ whose effect contains \g\, and put the preconditions of
       \op\ onto \G.
 \item If no \op\ is available at the previous step, then back-up; viz.,
       \textit{choose} another operator for an ancestor of the current
       goal.  
\end{enumerate}

At the third step, one needs to \textit{choose} an operator, but most of
the time it is not deterministic (indeed, if it is always deterministic,
nothing is fun to solve problems!).  So, one must estimate the fitness
of the operator and envision the success of its application.  However,
such estimation and envisioning are not easy tasks for human being.  We
need a scaffolding technique for them.  

At the fourth step, one needs to overcome an impasse by seeking an
alternative operator.  This procedure requires one to determine where to
back-up.  However, since there might be several points to be able to
back-up in a complex problem, to deterine where to back-up requires to
maintain a memory in a systematic way which, apparently, is not easy for
novices.  Thus, it is desired to reify a backing-up procedure.

Second, showing a problem-solving tree might not help students to
understand a process of problem solving.  To explain why, we need to
break down the ``tree'' into meaningful pieces;

\begin{itemize}
 \item A \textbf{proof tree} is an AND-tree to show a proof.
       \footnote{This should be reffered to as a \textit{solution} tree
       in general.  However, we prefer the word ``proof,'' because we
       are working on geometry theorem proving.}
 \item A \textbf{search tree} is an OR-tree to show how to search a
       solution.
 \item A \textbf{problem tree} is an AND/OR-tree to show an entire
       search space.
\end{itemize}

Figure~\ref{fig:tree}~shows an example of those trees on a tiny problem
with four operators.  Most ITSs utilize a problem tree.  For example,
\AlgebraTutor\ \cite{WhoIsIt}, \GeometryTutor\ \cite{Anderson85},
\RelatedRatesTutor\ (a calculus tutor) \cite{Singley90}, \Angle\ (a
geometry tutor) \cite{Koedinger93}, and \Gil\ (a LISP tutor)
\cite{Merrill94} all offer students a partial paroblem tree to build up
a solution.   **** NEED FOR A CITATION FOR THE ALGEBRA TUTOR ****

\begin{figure}[tb]
 \center
 [[ SIMPLE EXAMPLES ARE SHOWN HERE ]]
 \caption{An example of the trees.}
 \label{fig:tree}
\end{figure}

The major problems of using the problem tree as a direct media of
instruction include, among other things, (a) since a problem tree is
mixing up AND-trees and OR-trees which in turn results in a big tree, it
is virtually confounding students to see what to see, and thus an
attention tends to be loose; in other words, it is difficult to read
necessary information off the tree, (b) since chronological information
is not embedded into the tree, it is difficult to see how the search is
conducted, and (c) back-up is not shown at all.

Although the goal scaffolding, a version of reification of a proof tree,
facilitates students to learn how to conduct backward inference, it does
not help students learn backing-up procedures at all.  **** NEED
CITATION ****

On the other hand, a search tree shows both a history of search and the
back-up procedures.  Thus, it is the search tree that we need to utilize
in a complex problem-solving domain.  However, it still suffers from the
problem of dilute attention.  

In sum, it is a nondeterministic characteristic of backward inference
that makes learning in a complex problem-solving domain difficult.  We
need to provide students with scaffolding both for choosing operators
and for backing-up at dead-ends.  The search tree has potential
information to carry out those scaffoldings, but it still remains the
problem of dilutes attention.  Consequently, the challenge here is how
to provide a compact reification of a search tree.

In this paper, we discuss a reification of problem-solving strategies
for an advanced geometry theorem proving.  We especially focus on
teaching construction of auxiliary lines and points, which is one of the
most challenging and creative parts of geometry theorem proving.
Figure~\ref{fig:al}~shows an example of the problem requiring
construction.  In the remaining sections, we first discuss the major
issues to teach geometry theorem proving followed by an overview of the
previous works.  In section~\ref{sec:gw}, we introduce a GUI to reify a
search tree generated by GRAMY -- an automated theorem prover for
auxiliary line problems.  Finally, in section~\ref{sec:discussion}, we
discuss how the reification provides students with better scaffolding.

\begin{figure}[t]
 \center
 \mbox{
 \begin{minipage}{.4\textwidth}
  \resizebox{\textwidth}{!}{\includegraphics{../../Problems/P115-X}}
 \end{minipage}
 \begin{minipage}{.4\textwidth}
  \begin{tabbing}
   \begin{tabular}{rl}
    Given: & $BC = 2AB$ \\
    & $D$ midpoint of $BC$ \\
    & $E$ midpoint of $BD$ \\
    Goal: & $\angle EAD = \angle DAC$
   \end{tabular}
  \end{tabbing}
 \end{minipage}
 }
 \caption{An example of the problem that needs a construction.}
 \label{fig:al}
\end{figure}
